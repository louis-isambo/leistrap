!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = t || self).leistrap = e() }(this, function () {
    var r = 32; function o() { const i = {}; var a = {}, o = null; const r = { send: t => { o = t } }; var l, t = { invoke: async function (t, e, ...s) { async function n() { i[t].listener(r, ...s), e && e(o), o = null } v.has(t, i) ? v.after(1, n) : a[t] = () => v.after(1, n) }, handle: async function (t, e) { i[t] = { listener: e }, v.has(t, a) && (a[t](), a = v.copyObject(a, !1, !0, t)) } }; return l = 0, t.handle("readContent", function (t, e, s, n) { n = n || 1e3; var i = (s = s || []).length, a = setInterval(function () { e(s[l]), l + 1 === i && clearInterval(a), l++ }, n) }), t } const v = { isUndifend: t => !t, isArray: t => -1 < t.constructor.toString().indexOf("Array"), isObject: t => -1 < t.constructor.toString().indexOf("Object"), isString: t => -1 < t.constructor.toString().indexOf("String"), isNumber: t => !isNaN(t), isFunction: t => "function" == typeof t, setEmptyArray: t => t.splice(0, t.length), isNone: function (t) { return this.isString(t) && "" == t }, isEmpty: t => 0 === t.length || 0 === Object.keys(t).length, has: (t, e) => e.indexOf ? -1 < e.indexOf(t) : e.hasOwnProperty(t), isTypeOf: (t, e) => t instanceof e, copyObject: function (e, s, n = !1, ...i) { return s = s || {}, e = e || {}, Object.keys(e).forEach(t => { this.has(t, s) && !n || this.has(t, i) || (s[t] = e[t], this.isArray(s) && (s[t] = e[t])) }), s }, copyArray: function (t, s, n = !1) { return s = s || [], t && t.forEach((t, e) => { this.has(t, s) && !n || s.push(t) }), s }, getUrl: t => t.match(/http+(s|\b):\/\/[^ ]*(?=\b)+(\s|\b|\/)*/gi), hasUrl: function (t) { return !!this.getUrl(t) }, arrayRemove: (t, e) => e.splice(t, 1), arrayReplace: (t, e, s) => s.splice(t, 1, e), arrayInsert: (t, e, s) => { e.splice(t, 0, s) }, tryCode: (t, e) => { try { t() } catch (t) { e && e(t) } }, after: (t, e, ...s) => setTimeout(e, t, s), loopObj: (s, n = (t, e, s, n) => t) => { if (s) { let t = 0, e = !1; for (var i in s) t++, e = t === Object.keys(s).length, n(s[i], i, t - 1, e) } }, bindFunc: (e, s) => function (...t) { return e.call(s, ...t) }, arrAddWhen: (t, e, s, n, i) => { s <= n && (t && t.push(e), i) && i(e) }, arrBegin: (t, e) => { t && e() }, initObj: (t, e) => { }, objKeysToLowerCase: function (t) { const s = {}; return this.loopObj(t, (t, e) => s[e.toLowerCase()] = t), s }, filter: function (t, e) { const s = {}; return this.loopObj(t, (...t) => { e(...t) && (s[t[1]] = t[0]) }), s }, defineObj: (t, e, s, n = !1) => Object.defineProperty(t, e, { value: s, writable: n }), countArray: function (e, t) { var s = t; return function () { s === e.length - 1 && (s = 0); var t = e[s]; return s++, t } } }, l = { getElementRect: t => t.getBoundingClientRect(), getElementTextContent: t => t.textContent, getElemAttr: (t, e) => t.getAttribute(e), getGivenAttr: t => t.getAttributeNames(), getPreviousElem: t => t.previousElementSibling, getNextElem: t => t.nextElementSibling, setElemAttr: (t, e, s) => t.setAttribute(e, s), animateElement: (t, e, s) => t.animate(e, s), setAllAttr: t => t.attributes, setText: (t, e) => t.textContent = e, elementHasAttr: (t, e) => t.hasAttribute(e), elementHasNode: (t, e) => t.contains(e), elementHasClass: (t, e) => t.matches(e), elementSelfRemove: t => t.remove(), elementRemoveAttr: (t, e) => t.removeAttribute(e), elementSelfReplace: (t, e) => t.replaceWith(e), elementGetScreen: (t, e) => t.scrollIntoView(e), elementAfter: (t, e) => t.after(e), elementBefore: (t, e) => t.before(e), elementRemoveEvent: (t, e, s, n) => t.removeEventListener(e, s, n) }; const C = { setStyleProp: (t, e, s) => t._conf.style[e] = s, hasConf: t => !!t && !v.isUndifend(t._conf), addClassList: (t, e) => { t.attr || (t.attr = {}), t.attr.className || (t.attr.className = []), t.attr.className.push(e) }, addPW: (t, e, s, n) => { v.isUndifend(t) || e._conf || n.push(s) }, setInnerHtml: (t, e) => { t._conf.innerHTML = e }, append: function (t, e, s, n, i, a) { t._conf ? (e = e.point || e, i || a ? i && !a && t.content.get(i) && (t._conf.insertBefore(e.render(), i._conf), t.content.insertBefore(i, e)) : t._conf.append(e.render()), e.state = "active", e.parent = t._conf, e.lsParent = t, i || t.content.push(e), e.index && t.content.addIndex(e)) : this.addPW(!0, t, s, n) }, appendElement: (e, ...t) => { t.forEach(t => e.add(t)) }, topNaveDropDowns: (e, s, t) => { v.isArray(t) && t.forEach(t => { v.isArray(t) && (0 != t.length && 1 === t.length ? v.tryCode(function () { s.push(e.Li({ content: [t[0].MainD] })) }) : v.tryCode(function () { v.arrayInsert(t[0], s, e.Li({ content: [t[1].MainD] })) })) }) }, insertItemFlat: (e, s, t, n, i) => { v.isArray(t) && t.forEach(t => { v.isArray(t) && (0 != t.length && 1 === t.length ? v.tryCode(function () { s.push(e.Li({ content: [v.isUndifend(n) ? t[0] : t[0][n]], attr: i ? { className: i } : void 0 })) }) : v.tryCode(function () { v.arrayInsert(t[0], s, e.Li({ content: [v.isUndifend(n) ? t[1] : t[1][n]], attr: i ? { className: i } : void 0 })) })) }) }, setTooltip: (t, e, s = "top") => t.Card({ attr: { className: ["leis-tooltip", s] }, content: [t.P({ text: e, attr: { className: ["leis-tooltip-content"] } })] }), setSearchBar: (t, e) => { v.isUndifend(e.otherAttr) && (e.otherAttr = {}), v.isUndifend(e.attr) && (e.attr = {}); let [s, n, i] = [{ otherAttr: { type: "search", autocomplete: !1 } }, { attr: { className: ["leis-searchBar"] } }, {}]; return v.copyObject(e.otherAttr, s.otherAttr), v.copyObject(e.attr, n.attr), [s, n].forEach(t => v.copyObject(t, i)), v.copyObject(e, i), v.isUndifend(e.attr) || v.copyArray(e.attr.className, i.attr.className), t.Input(i) }, whenSelectAutoComplete: function (t, e, s) { v.isFunction(t) && t(e), s.setValue(e) }, searchBarFocus: function (t, e) { t.addEvent("focus", function () { e.addClass("clicked") }) }, whenAutoItemClicked: function (t, e, s, n, i) { t.addEvent("click", () => { this.whenSelectAutoComplete(e.whenSelect, i, s), n.removeClass("clicked") }) }, setAutoCompletion: function (c, d, p, t, m) { function u(t, e, s) { v.isObject(e) ? (e.icon && t.add(e.icon), t.add(s), e.subTitle && (t.add(e.subTitle), e.subTitle.addClass("aut-item-subTitle"))) : t.add(s) } d = d || [], (m = m || {}).limit || (m.limit = 100); const f = c.Card({ attr: { className: ["leis-autoComplateCard"] } }); var e = c.Card({ attr: { className: ["leis-autComplate-container"] }, parent: f }); const g = c.GroupItem({ parent: e }); return v.isUndifend(t) || (v.copyArray(t, d), t.forEach(t => { var e = c.Li(), s = v.isObject(t) ? t.text : t; u(e, t, c.Span({ text: s })), this.whenAutoItemClicked(e, m, p, f, s), g.addItem(e) })), this.searchBarFocus(p, f), p.addEvent("keyup", function (t) { g.removeAll(); var e, s, n, i, a, o, r = 0, l = this.getAttr("value") ? this.getAttr("value").toLowerCase() : ""; for (e of d) { if (m.limit == r) break; var h = v.isObject(e) ? e.text : e; v.has(l, h.toLowerCase()) && !v.isEmpty(l) && r <= m.limit && (h = g, s = e, n = f, o = a = i = void 0, i = v.isObject(s) ? s.text : s, a = c.Span({ text: i }), u(o = c.Li(), s, a), C.whenAutoItemClicked(o, m, p, n, i), h.addItem(o), r += 1) } }), f }, removeEvent: function (t, e, s, n, i, a) { this.hasConf(t) ? l.elementRemoveEvent(t._conf, e, s, n) : this.addPW(!0, t, i, a) }, removeAttr: function (t, e, s, n) { this.hasConf(t) ? l.elementRemoveAttr(t._conf, e) : this.addPW(!0, t, s, n) }, getScreen: function (t, e, s, n) { this.hasConf(t) ? l.elementGetScreen(t._conf, e) : this.addPW(!0, t, s, n) }, getRect: function (t, e, s) { if (this.hasConf(t)) return l.getElementRect(t._conf); this.addPW(!0, t, e, s) }, kb: { t: [86, 111, 116, 114, 101, 32, 118, 101, 114, 115, 105, 111, 110, 32, 100, 39, 101, 115, 115, 97, 105, 32, 101, 115, 116, 32, 101, 120, 112, 105, 114, 233, 101, 44, 32, 118, 101, 117, 105, 108, 108, 101, 122, 32, 112, 114, 111, 99, 117, 114, 101, 114, 32, 108, 97, 32, 118, 101, 114, 115, 105, 111, 110, 32, 99, 111, 109, 112, 108, 101, 116, 101, 44, 32, 99, 111, 110, 116, 97, 99, 116, 32, 58, 32, 43, 50, 52, 51, 56, 57, 54, 48, 48, 55, 57, 52, 49, 46, 32, 77, 101, 114, 99, 105, 32, 33], ti: [76, 101, 105, 115, 116, 114, 97, 112, 32, 73, 110, 102, 111], y: 2023, m: 11, s: 1, e: 25 }, destroyAll: t => { t.content.forEach(t => { l.elementSelfRemove(t._conf) }) }, setElement: t => v.isUndifend(document) ? void 0 : document.createElement(t), removeAllContent: t => v.setEmptyArray(t.content), getText: t => t.text, setConf: (t, e) => t._conf = e, getElementPosition: (s, t) => { let n; return t.forEach((t, e) => { C.sameLsConf(t, s) && (n = e) }), n }, setAllreasyRemovedWidget: () => new Error("can not accss this element or it's already removed"), setClassName: function (t, e, s, n) { this.hasConf(t) ? t._conf.className = e : this.addPW(e, t, s, n) }, isRemoved: t => "removed" === t.state, addCssFile: (t, e) => t.head.append(e.render()), destroyElement: function (t, e, s) { if (this.hasConf(t.lsParent) && !v.isUndifend(t.lsParent)) { if (this.isRemoved(t)) throw this.setAllreasyRemovedWidget(); v.tryCode(() => { t._conf.parentElement.removeChild(t._conf) || l.elementSelfRemove(t._conf) }), t.state = "removed", t.lsParent.content.remove(t) } else this.addPW(!0, t, e, s) }, removeElement: function (t, e, s, n, i) { v.isTypeOf(e, s) && this.hasConf(t) ? t.content.remove(e) : this.addPW(e, t, n, i) }, setInnerText: function (t, e, s, n, i) { !v.isUndifend(e) && this.hasConf(t) ? (t._conf.innerText = e, t[s] = e) : this.addPW(e, t, n, i) }, hideElement: function (t, e, s, n, i) { this.hasConf(t) ? t._conf.style = `display:${i};` + e : this.addPW(!0, t, s, n) }, showElement: function (t, e, s, n, i) { this.hasConf(t) ? t._conf.style = `display:${i};` + e : this.addPW(!0, t, s, n) }, setElementAttr: function (t, e, s, n) { this.hasConf(t) ? t._conf.setAttribute(e.name, e.value) : this.addPW(e, t, s, n) }, addElementEvent: function (t, e, s, n) { this.hasConf(t) && t._conf.addEventListener(e, s, n) }, toggleElementClass: function (t, e, s, n) { this.hasConf(t) ? t._conf.classList.toggle(e) : this.addPW(e, t, s, n) }, removeElementClass: function (t, e, s, n) { this.hasConf(t) ? t._conf.classList.remove(e) : this.addPW(e, t, s, n) }, addElementClass: function (t, e, s, n) { this.hasConf(t) ? t._conf.classList.add(e) : this.addPW(e, t, s, n) }, setElementStyle: function (t, e, s, n) { this.hasConf(t) ? t._conf.style = "" + e : this.addPW(e, t, s, n) }, sameLsConf: (t, e) => t.leisBtnConfId === e.leisBtnConfId, kbi: function (t) { if (t) { let e = ""; return t.forEach(t => e += "" + String.fromCharCode(t)), e } }, addInnerhtml: (t, e) => { t._conf.innerHTML += e._conf.innerHTML }, setLeisCardContent: (t, e, s) => { v.isTypeOf(t.parent, s) && t.parent.content.push(e) }, getRemovedElement: function (t) { const e = []; return v.loopObj(t.content.getRemoved(), t => e.push(t)), e }, dollarEvent: function (s, t) { v.loopObj(s.events, (t, e) => { e = e.split("$"); 1 == e.length && s.addEvent(e[0], t), 2 == e.length && s.addEvent(e[0], t, e[1]), 3 == e.length && s.addEvent(e[0], t, e[1], e[3]) }) } }, h = { _v1: (t, n, i, a, o, r) => { if (v.isArray(t) && v.isFunction(n)) { let s = o.initCol ? o.count + 1 : o.count; r && (s = r - 1), t.forEach((t, e) => n(t, i, e + s, a, o, r)) } }, _v2: (t, s, n, i, a, o) => { v.isArray(t) && t.forEach((t, e) => { v.isObject(t) && v.isFunction(s) && s(t, n, e, i, a, o) }) }, _v3: (t, e, s, n, i, a) => { v.isUndifend(n.content[e]) || v.isUndifend(n.content[e].content[s]) || (i.count = e, i.initCol = !0, n.content[e].content[s].setText(t.text), t.widget && n.content[e].content[s].add(t.widget)) }, columnError: () => new Error("column not found"), rowNotFound: () => new Error("row not found"), insertData: function (t, e, s, n) { this._v1(t, this._v2, this._v3, e, s, n) }, getCell: function (t, e, s) { if (t.content[s - 1]) { if (t.content[s - 1].content[e - 1]) return t.content[s - 1].content[e - 1]; throw this.columnError() } throw this.rowNotFound() }, getRow: function (t, e) { if (t.content[e - 1]) return t.content[e - 1]; throw this.rowNotFound() }, getColumnStr: function (t, e) { if (v.isString(t) && e) { if (v.has(t, e)) return e.indexOf(t) + 1; throw this.columnError() } return t }, getColumn: function (t, e, s) { e = this.getColumnStr(e, s); const n = []; return t.content.forEach(t => { t.content[e - 1] && n.push(t.content[e - 1]) }), n }, setHeading: function (s, t) { v.isArray(t) && t.forEach((t, e) => { s.content[e] && s.content[e].setText(t) }) }, spanCol: (t, e) => t.addAttr("colspan", e), spanRow: (t, e) => t.addAttr("rowspan", e), adaptTableCol: function (t, e, s, n) { let i = []; if (e) { let s = C.getElementPosition(t, e.content); e.content.forEach((t, e) => { e > s && v.arrAddWhen(i, t, e, n) }), i.forEach(t => { t.destroy() }) } else C.addPW(!0, t, () => { setTimeout(() => { s.spanCol(n) }, 200) }, t.getPropWait()) }, forEachCol: (t, s) => t.forEach((t, e) => s(t, e)), dropColumn: function (t, e) { e = [e]; v.copyArray(t, e), this.forEachCol(e, (t, e) => { t.lsParent ? t.destroy() : C.addPW(!0, t, () => { v.after(200, () => { t.lsParent.remove(t) }) }, t.getPropWait()) }) } }, j = ["light", "dark", "success", "danger", "warning", "info", "primary", "secondary"], n = { size: { small: "leis-btn-small", normal: "leis-btn-normal", large: "leis-btn-large" }, type: { light: "leis-btn-light", dark: "leis-btn-dark", success: "leis-btn-success", danger: "leis-btn-danger", warning: "leis-btn-warning", info: "leis-btn-info", primary: "leis-btn-primary", secondary: "leis-btn-secondary" }, btnStyle: { normal: "normal", outline: "outline" }, setOutiline: function () { const e = {}; return j.forEach(t => e[t] = "leis-outline-btn-" + t), e } }, e = { setOutiline: (t, e) => { t.addClass(e) }, changeSize: (e, t) => (v.has(t, n.size) && (v.loopObj(n.size, t => e.removeClass(t)), e.addClass(n.size[t])), e), changeType: function (e, t) { return v.loopObj(n.setOutiline(), t => e.removeClass(t)), v.has(t, n.type) && (v.loopObj(n.type, t => e.removeClass(t)), e.addClass(n.type[t]), e.type = t, e.outline) && this.setOutiline(e, n.setOutiline()[e.type]), e }, changeBtnStyle: function (e, t) { return v.has(t, n.btnStyle) && (v.loopObj(n.setOutiline(), t => e.removeClass(t)), "normal" === t ? (v.loopObj(n.setOutiline(), t => e.removeClass(t)), e.outline = !1) : (this.setOutiline(e, n.setOutiline()[e.type]), e.outline = !0)), e }, setGroupbtnType: function (s, t) { v.has(t, n.type) && (v.loopObj(n.type, (t, e) => { s.removeClass(e + "-group") }), s.addClass(t + "-group")) } }; function c() { leis.hasConf(this.main) ? (leisDOM.elementSelfRemove(this.main._conf), this.main.state = "removed") : leis.addPW(!0, this.main, () => { obj.after(200, () => { this.destroy() }) }, this.main.getPropWait()) } const d = { lDropDown: [], PageControler: void 0, Callbacks: [] }; var p = ["title"], y = [], s = [], m = [], b = []; function u(e, s, t, n, i) { t.after(200, () => { n.forEach(t => t(e, s, i)) }) } class f { constructor(t) { this.leisBtnConfId = t } } function W(t, e) { t.leisBtnConfId.setText(e) } function M(t, e, s, n, i) { t.leisBtnConfId.addEvent(e, s, n, i) } function H(t, e, s, n) { t.leisBtnConfId.removeEvent(e, s, n) } function R(t) { e.setGroupbtnType(this.main, t) } function F(t) { this.main.remove(t.leisBtnConfId) } function $() { this.main.removeAll() } function U(e, s) { C.hasConf(this.main) ? this.main.content.forEach(t => { e && t.setStyleProp("width", e), e && t.setStyleProp("height", s) }) : C.addPW(!0, this.main, () => { this.setBtnSize(e, s) }, this.main.getPropWait()) } function V(t) { t = _.Button({ text: t }); return t.addAttr("class", "leis-groupBtn-item"), this.main.add(t), new f(t) } function G(t) { const e = _.Div({ parent: t }); C.addClassList(e, "leis-groupBtn-container"); var t = _.Div({ parent: e }), s = (C.addClassList(t, "leis-groupBtn-card"), { add: V, destroy: c, remove: F, setText: W, on: M, removeEvent: H, removeAll: $, setBtnSize: U, setType: R, setSize: function (t) { t && this.container.setStyleProp("width", t) } }); return s.main = t, s.render = function () { return e.render() }, s.container = e, s } class z { constructor(t) { this.element = t } setSize(t) { return e.changeSize(this.element, t), this } setType(t) { return e.changeType(this.element, t), this } setBtnStyle(t) { return e.changeBtnStyle(this.element, t), this } setIcon(t) { var e; return t && v.isString(t) && (e = this.getText(), this.setText(" "), this.element.removeAll(), t = _.Span({ content: [_.I({ otherAttr: { class: t } })] }), e = _.Span({ text: e }), this.element.addElements(t, e), C.addClassList(t, "leis-btn-icon"), this.element.addClass("leis-btn-w-icon"), Object.defineProperty(this, "icon", { value: !0 }), Object.defineProperty(this, "txtElem", { value: e })), this } setText(t) { return (this.icon ? this.txtElem : this.element).setText(t), this } getText() { return (this.icon ? this.txtElem : this.element).getText() } render() { return this.element.render() } removeEvent(t, e, s) { return this.element.removeEvent(t, e, s), this } destroy() { this.element.destroy() } getScreen() { this.element.getScreen() } on(t, e, s, n) { return this.element.addEvent(t, v.bindFunc(e, this), s, n), this } } function E(t = 0, e = 1) { var s = "abcdefghijklmnopqrstuvwxyz", n = ["dh5263ayLogl", "0123456789", s, s.toLocaleUpperCase()]; let [i, a, o] = ["", 0, 0]; for (var r = function (e, s) { { if ("number" != typeof e || "number" != typeof s) throw new Error("can not execute " + ("number" != typeof e ? typeof e : typeof s)); var n = []; for (let t = e; t < s; t++)n.push(t); return function (e) { { var t; if ("object" == typeof e) return t = Object.keys(e), e[t[Math.floor(Math.random() * t.length)]]; if ("function" == typeof e || "boolean" == typeof e || void 0 === e || "symbol" == typeof e) throw new Error("can not execute a " + typeof e); if ("number" != typeof e) return "string" == typeof e ? e[Math.floor(Math.random() * e.length)] : void 0; var s = []; for (let t = 0; t < e; t++)s.push(t); return s[Math.floor(Math.random() * s.length)] } }(n) } }(t, e); o < r;) { for (a = 0; a < n.length; a++) { var l = n[Math.floor(Math.random() * n.length)]; i += l[Math.floor(Math.random() * l.length)] } o++ } return i } function g(t, e) { if (v.has(e.linkName, t)) throw e.linkName = `Gen_${e.linkName}_` + generateId(1, 3), new Error("Link name must unique") } function P(t, e) { t.point ? e(t.point) : e(t) } function w(t, e, s = !1) { if (v.has(e, t) && !s) throw e.pageName = e.pageName + "_" + generateId(2, 3), new Error("PageName must be unique"); if (!v.has(e, t) && s) throw new Error("PageName not exist") } class q extends Array { #index; #removed; #obj; constructor(t, ...e) { super(), this.#index = {}, Object.defineProperty(this, "Name", { value: "Content", writable: !1 }), this.#removed = {}, this.#obj = t, this.add(e), this.forEach(t => { this.addIndex(t) }) } addIndex(t) { g(this.#index, t), t.linkName || (t.linkName = E(2, 5)), this.#index[t.linkName] = t } add(t) { t.forEach(t => { this.push(t) }) } get(t) { return this.#index[t.linkName] } insertBefore(t, e) { for (var s, n = 0; n < this.length; n++)if (t.leisBtnConfId === this[n].leisBtnConfId) { s = n; break } this.splice(s, 0, e) } findElem(t) { return this.#index[t] } update() { this[0]._conf; var t = this.map(t => t); this.#obj.removeAll(), this.#obj.addElements(...t) } remove(s) { this.#removed || (this.#removed = {}), this.forEach((t, e) => { t.leisBtnConfId === s.leisBtnConfId && (this.splice(e, 1), "removed" !== (this.#removed[t.leisBtnConfId] = t).state && (t.destroy(), t.state), s.index) && v.has(t.linkName, this.#index) && (this.#index = v.copyObject(this.#index, !1, !1, s.leisBtnConfId)) }) } getRemoved() { return this.#removed } reactive(t) { this.#removed || (this.#removed = {}); var e = t.leisBtnConfId; if (v.has(e, this.#removed)) return t.state = "active", t.lsParent.add(t), t = this.#removed[e], this.#removed = v.copyObject(this.#removed, !1, !1, e), t } empty() { v.loopObj(this.#removed, t => { }), this.#removed = null } } function K(e, s) { e = e || {};["className", "id", "name"].forEach(t => { e[t] && (s[t] = e[t]) }) } function J(t, e, s) { var n = String.fromCharCode(32); t && e && (e = t.split(n), e = v.has("outline", e) ? "leis-outline-btn-" + t : "leis-btn-" + t, s.className += n + "leis-btn" + n + e) } function Q(t, e) { t && l.setText(e, t) } function X(t, e, s) { t && e && l.setElemAttr(s, "for", e) } function Y(t, e, s, n) { t && s && (l.setElemAttr(e, "src", s), n) && l.setElemAttr(e, "alt", n) } function Z(e, s) { p.forEach(t => { e[t] && l.setElemAttr(s, t, e[t]) }) } function t() { return { header: _.Div(), body: _.Div(), footer: _.Div() } } class x { #card = t(); constructor(t, e) { this.element = t, e.content && (v.arrayRomove(C.getElementPosition(this.element, e.content), e.content), e.add(this)), this.header = void 0, this.footer = void 0, this.title = void 0, this.img = void 0, C.addClassList(this.element, "leis-card"), C.addClassList(this.#card.header, "leis-card-header"), C.addClassList(this.#card.body, "leis-card-body"), C.addClassList(this.#card.footer, "leis-card-footer"), v.defineObj(this, "body", this.#card.body), v.defineObj(this, "content", []), this.boxSh = !1, this.leisBtnConfId = E(10, 20), Object.defineProperty(this, "addElemClass", { value: function (t) { this.addClass(t) } }) } setSize(t = "auto", e = "auto") { this.element.setStyleProp("width", t), this.element.setStyleProp("height", e) } destroy() { C.hasConf(this.#card.body) ? (l.elementSelfRemove(this.element._conf), this.state = "removed") : C.addPW(!0, this.#card.body, () => { v.after(200, () => { this.destroy() }) }, this.#card.body.getPropWait()) } hide(t) { this.element.hide(t) } show() { this.element.show() } setBsh() { this.element.addClass("boxSh-off") } setBsh() { this.element.removeClass("boxSh-off") } add(t) { this.body.add(t) } remove(t) { this.#card.body.remove(t) } removeAll(t) { var e = this.#card.body.content[0]; this.#card.body.removeAll(t), this.#card.body.add(e) } render() { this.boxSh ? this.element.removeClass("boxSh-off") : this.element.addClass("boxSh-off"); var t = []; v.copyArray(this.element.content, t), v.copyArray(this.content, t), t.forEach(t => this.#card.body.add(t)); const e = [this.#card.body]; var s; if (this.header && (v.isTypeOf(this.header, A) && (e.unshift(this.#card.header), this.#card.header.add(this.header)), v.isString(this.header) && (e.unshift(this.#card.header), this.#card.header.setText(this.header)), Object.defineProperty(this, "changeHeader", { value: function (t) { v.isTypeOf(t, A) ? (this.#card.header.removeAll(), this.#card.header.add(t)) : this.#card.header.setText(t) } })), this.title && v.isString(this.title)) { const n = _.H3({ text: this.title }); C.addClassList(n, "leis-card-title"), this.#card.body.content.unshift(n), Object.defineProperty(this, "changeTitle", { value: function (t) { n.setText(t) } }) } if (this.img) { const i = _.Img({ otherAttr: { src: this.img.path } }), a = _.Div({ content: [i] }); C.addClassList(i, "leis-img"), C.addClassList(a, "leis-img-card"), this.img.pos = this.img.pos || "top", "top" === this.img.pos ? (a.addClass("leis-card-img-top"), s = C.getElementPosition(this.body, e), v.arrayInsert(s, e, a)) : "bottom" === this.img.pos && (a.addClass("leis-card-img-bottom"), s = C.getElementPosition(this.body, e), v.arrayInsert(s + 1, e, a)), Object.defineProperty(this, "changeImg", { value: function (t) { i.addAttr("src", t) } }) } return this.footer && (v.isTypeOf(this.footer, A) && (e.push(this.#card.footer), this.#card.footer.add(this.footer)), v.isString(this.footer) && (e.push(this.#card.footer), this.#card.footer.setText(this.footer)), Object.defineProperty(this, "changeFooter", { value: function (t) { v.isTypeOf(t, A) ? (this.#card.footer.removeAll(), this.#card.footer.add(t)) : this.#card.footer.setText(t) } })), this.element.content = e, this.element.render() } } const A = function () { class g extends class { #propsWait = []; #init; constructor({ parent: t = "object" == typeof module ? new String : g, text: e = new String || void 0, type: s = new String, content: n = [], eventType: i = new String, eventOnce: a = function (t) { }, attr: o = { id: void 0, className: [], name: void 0 }, otherAttr: r = {}, addData: l = {}, events: h = {}, innerHtml: c, autoClick: d, tooltip: p, linkName: m, index: u }) { y.forEach(t => t(this)); const { ...f } = this; if (this.eventType = i, this.eventOnce = a, this.parent = t, this.ElementType = "", this.state = "active", this.text = e, this.type = s, this.content = new q(this, ...n), this.index = u, this.attr = o, this.lblFor = "", this.value = "", this.href = "", this.otherAttr = r, this.addData = l, Object.defineProperty(this, "e", { value: {} }), this.wEnvent = { addEvents: [] }, this.linkName = m, this.events = h, C.addPW(c, this, () => { C.setInnerHtml(this, c) }, this.#propsWait), C.addPW(d, this, () => { setTimeout(() => { this.getAttr("click") }, 10) }, this.#propsWait), C.addPW(p, this, () => { this.add(C.setTooltip(_, p.text, p.postion)) }, this.#propsWait), "object" == typeof this.attr.className) try { this.attr.className = this.attr.className.join(String.fromCharCode(32)) } catch (t) { throw new Error("can not read type of " + typeof this.attr.className) } void 0 !== this.parent && (void 0 !== this.parent.content && (this.point ? this.parent.content.push(this.point) : this.parent.content.push(this)), C.setLeisCardContent(this, this, x)), b.forEach(t => t(f, this)), this.#init && this.#init() } add(t) { const { ...e } = this; C.append(this, t, () => { this.add(t) }, this.#propsWait), u(e, this, v, b, { method: "add", param: [t] }) } addBefore(t, e) { const { ...s } = this; C.append(this, e, () => { this.add(e) }, this.#propsWait, t), u(s, this, v, b, { method: "addBefore", param: [e] }) } addElements(...t) { const { ...e } = this; C.appendElement(this, ...t), u(e, this, v, b, { method: "&ddElements", param: t }) } setStyleProp(t, e) { const { ...s } = this; C.hasConf(this) ? (C.setStyleProp(this, t, e), u(s, this, v, b, { method: "setStyleProp", param: [t, e] })) : C.addPW(t, this, () => { this.setStyleProp(t, e) }, this.#propsWait) } getScreen(t) { const { ...e } = this; C.getScreen(this, t, () => { this.getScreen(t) }, this.#propsWait), u(e, this, v, b, { method: "getScreen", param: [t] }) } getPropWait() { return this.#propsWait } removeAll() { if (C.hasConf(this)) { const { ...t } = this; C.destroyAll(this), u(t, this, v, b, { method: "removeAll", param: [] }) } C.removeAllContent(this) } removeAttr(t) { const { ...e } = this; C.removeAttr(this, t, () => { this.removeAttr(t) }, this.#propsWait), u(e, this, v, b, { method: "removeAttr", param: [t] }) } removeEvent(i, t, e) { const { ...s } = this; let n; this.e[i] ? ("*" !== t && C.removeEvent(this, i, this.e[i][t], e, () => { v.after(200, () => { this.removeEvent(i, callback, e) }) }, this.#propsWait), "*" === t && (n = !0, v.loopObj(this.e[i], (t, e, s, n) => { this.removeEvent(i, e) })), u(s, this, v, b, { method: "removeEvent", param: [i, t, e] })) : console.log(i + " event not found") } getRemovedElement() { return C.getRemovedElement(this) } }{ destroy() { const { ...t } = this; C.destroyElement(this, () => { v.after(200, () => { this.destroy() }) }, this.getPropWait()), u(t, this, v, b, { method: "destroy", param: [] }) } setText(t) { const { ...e } = this; C.setInnerText(this, t, "text", () => { this.setText(t) }, this.getPropWait()), u(e, this, v, b, { method: "setText", param: [t] }) } getText() { return this.text || this._conf.innerText } remove(t) { const { ...e } = this; C.removeElement(this, t, g, () => { this.remove(t) }, this.getPropWait()), u(e, this, v, b, { method: "remove", parm: [t] }) } setClassName(t) { const { ...e } = this; C.setClassName(this, t, () => { this.setClassName(t) }, this.getPropWait()), u(e, this, v, b, { method: "setClassName", parm: [t] }) } hide(t) { const { ...e } = this; C.hideElement(this, t, () => { this.hide(t) }, this.getPropWait(), "none"), u(e, this, v, b) } show(t) { const { ...e } = this; C.hideElement(this, t, () => { this.hide(t) }, this.getPropWait(), "block"), u(e, this, v, b, "show") } setStyle(t) { const { ...e } = this; C.setElementStyle(this, t, () => { this.setStyle(t) }, this.getPropWait()), u(e, this, v, b, "setStyle") } addAttr(t, e) { const { ...s } = this; C.setElementAttr(this, { name: t, value: e }, () => { this.addAttr(t, e) }, this.getPropWait()), u(s, this, v, b, "addAttr") } addEvent(e, t, s, n) { const { ...i } = this; let a = 0; if (C.hasConf(this) && "function" == typeof t) { const r = t; function o(t) { r.call(this.currentElement, t), u(i, this, v, b, { name: s, method: "addEvent", eventType: e }) } C.addElementEvent(this, e, o, n), this.e[e] || (this.e[e] = {}), v.isEmpty(t.name) && a++, s ? this.e[e][s] = o : v.isEmpty(t.name) ? this.e[e]["LocalFunction" + a] = o : this.e[e][t.name] = o } else "function" == typeof t && this.wEnvent.addEvents.push({ eventType: e, callback: t, name: s, option: n }) } getAttr(t) { if (C.hasConf(this)) return "function" == typeof this._conf[t] ? this._conf[t]() : this._conf[t] || l.getElemAttr(this._conf, t); C.addPW(!0, this, () => { this.getAttr(t) }, this.getPropWait()) } getRect() { return C.getRect(this, () => { this.getRect() }, this.getPropWait()) } toggleClass(t) { C.toggleElementClass(this, t, () => { this.toggleClass(t) }, this.getPropWait()) } CASCADE() { this.content.forEach(t => { if ((t.parent === this || t.parent == g) && "removed" !== t.state) try { this._conf.append(t.render()), t.parent = this._conf, t.lsParent = this } catch (t) { } }) } removeClass(t) { const { ...e } = this; C.removeElementClass(this, t, () => { this.removeClass(t) }, this.getPropWait()), u(e, this, v, b, "removeClass") } addClass(t) { const { ...e } = this; C.addElementClass(this, t, () => { this.addClass(t) }, this.getPropWait()), u(e, this, v, b, "addClass") } bind(t, e, s) { _.extension.keymap, _.extension.keymap.Bind(this, t, e, s) } render() { if ("object" == typeof module) return "render Method from leistrap"; var t = C.setElement(this.ElementType); if (K(this.attr, t), J(this.type, "button" === this.ElementType, t), Q(this.text, t), X("label" === this.ElementType, this.lblFor, t), Y("img" === this.ElementType, t, this.src, this.alt), Z(this, t), "function" == typeof this.eventOnce) { var e = void 0 !== this.eventType ? "" !== this.eventType ? this.eventType : "$err" : void 0; if ("$err" === e) throw new Error("can not listen to event of null"); this.e[e] || (this.e[e] = {}), this.eventOnce.prototype.name ? this.e[e][this.eventOnce.prototype.name] = this.eventOnce : this.e[e][this.eventOnce.name] = this.eventOnce, t.addEventListener(e, this.eventOnce) } return t.leisConf = E(10, 20), C.setConf(this, t), this.leisBtnConfId = E(12, 20), void 0 !== (t.currentElement = this).content && "function" == typeof this.content.push && this.content.forEach(t => { t.point ? (v.tryCode(() => { this._conf.append(t.point.render()) }), t.point.parent = this._conf, t.point.lsParent = this) : (v.tryCode(() => { this._conf.append(t.render()) }), t.parent = this._conf, t.lsParent = this) }), void 0 !== this.otherAttr && "object" == typeof this.otherAttr && Object.keys(this.otherAttr).forEach(t => this._conf.setAttribute(String(t), String(this.otherAttr[t]))), 0 < this.wEnvent.addEvents.length && this.wEnvent.addEvents.forEach(t => this.addEvent(t.eventType, t.callback, t.name, t.option)), C.dollarEvent(this), 0 < this.getPropWait().length && this.getPropWait().forEach(t => t()), v.setEmptyArray(this.getPropWait()), s.forEach(t => t(this)), t } } return g }(); class tt extends A { getButton() { return new z(this) } groupBtn() { return this.destroy(), G(this.parent) } } class et extends A { getCard() { return new x(this, this.parent) } } class st extends A { } class nt extends A { } class i extends A { } class it extends A { } class a extends A { addItem(t) { "li" === t.ElementType && (this.content.push(t), this.CASCADE()) } } class at extends A { } class ot extends A { } class rt extends A { } class lt extends A { } class ht extends A { } class ct extends A { } function S() { return { add: Et, remove: pt, destroy: c, once: Pt, getChecked: mt, setLblText: ft } } function dt(t, e, s, n, i, a, o) { var r = E(4, 8); const l = _.Input({ otherAttr: { type: s, id: r }, addData: { value: e, event: { active: [], disable: [] } } }); e = _.Div(), n && l.addAttr("name", n), n = v.objKeysToLowerCase(a), a = v.copyObject(n, void 0, !1, "id", "name", "type"); v.loopObj(a, (t, e) => { l.addAttr(e, t) }); const h = _.Label({ lblFor: r, text: t }), c = _.Div({ content: [e] }); return this.autoComplete && v.has(s, ["text", "email", "password"]) ? (l.addClass("leis-autoInput"), l.addAttr("autocomplete", "false"), e.addClass("leis-autoComplate"), e.content = [l, C.setAutoCompletion(_, this.autoComplete.autoComplete, l, this.autoComplete.defaultValue, this.autoComplete)]) : (C.addClassList(e, this.ic), e.content = [l]), c.input = l, c.ic = e, t && (c.add(h), c.lbl = h), C.addClassList(c, this.className), C.addClassList(l, this.inputClassName), (i || (o || this).main).add(c), this.main.addData.inputs.push(l), "text" !== s && l.addEvent("click", function () { this.getAttr("checked") ? l.addData.event.active.forEach(t => t(l.addData.value)) : l.addData.event.disable.forEach(t => t(l.addData.value)) }), this.autoComplate = void 0, new f(c) } function pt(t) { this.main.remove(t.leisBtnConfId) } function mt() { let e = []; return this.main.addData.inputs.forEach(t => { t.getAttr("checked") && e.push(t.addData.value) }), v.isEmpty(e) ? void 0 : e } function ut(e) { this.main.addData.inputs.forEach(t => { e && t.addClass(e) }) } function ft(t, e) { t.leisBtnConfId.lbl.setText(e) } function gt(t) { return t.leisBtnConfId.input.getValue() } function vt(t, e) { t.leisBtnConfId.input.setValue(e) } function Ct(t, e, s, n) { t.leisBtnConfId.input.removeEvent(e, s, n) } function yt(t, e) { t.leisBtnConfId.ic.setStyleProp("width", e) } function bt(t, e, s, n, i) { t.leisBtnConfId.input.addEvent(e, s, n, i) } function Et(t, e, s, n, i) { return n = n || {}, v.bindFunc(dt, this)(t, e, this.type, this.radioName, s, n.attr, i) } function Pt(t, e, s) { "active" === e && t.leisBtnConfId.input.addData.event.active.push(s), "disable" === e && t.leisBtnConfId.input.addData.event.disable.push(s) } function wt(t) { const e = _.Div({ addData: { inputs: [] }, parent: t }); var t = E(2, 9), s = (C.addClassList(e, "leis-card-radioBtns-container"), S()); return s.type = "radio", s.className = "leis-radioBtns-card", s.inputClassName = "leis-radioBtn", s.radioName = t, s.main = e, s.render = function () { return e.render() }, s } function xt(t) { const e = _.Div({ addData: { inputs: [] }, parent: t }); C.addClassList(e, "leis-card-checkboxBtns-container"); t = S(); return t.type = "checkbox", t.className = "leis-checkboxBtns-card", t.inputClassName = "leis-checkboxtBtn", t.main = e, t.render = function () { return e.render() }, t } function At(t) { const e = _.Div({ addData: { inputs: [] }, parent: t }); C.addClassList(e, "leis-card-switchboxBtns-container"); t = S(); return t.type = "checkbox", t.className = "leis-switchboxBtns-card", t.inputClassName = "leis-switchboxtBtn", t.main = e, t.render = function () { return e.render() }, t } function N(t, e, s, n, i, a) { const o = _.Div({ addData: { inputs: [] }, parent: t }); C.addClassList(o, e); t = { add: Et, remove: pt, destroy: c, getValue: gt, setValue: vt, setLblText: ft, on: bt, addClass: ut, removeEvent: Ct, setSize: yt }; return t.type = s, t.ic = n, t.className = i, t.inputClassName = a, t.main = o, t.render = function () { return o.render() }, t } function St(t) { return N(t, ...k("text")) } function Nt(t) { return N(t, ...k("password")) } function kt(t) { return N(t, ...k("email")) } function k(t) { return ["leis-textboxinput-container", t, "leis-textbox-container", "leis-textbox-card", "leis-textinput"] } class Tt extends A { } class Bt extends A { #isComp = !1; setValue(t) { this._conf.value = t } getValue() { return this._conf.value } getRadio() { return this.#isComp || (this.#isComp = !0, this.destroy()), wt(this.parent) } getCheckBox() { return this.#isComp || (this.#isComp = !0, this.destroy()), xt(this.parent) } getTextBox() { return this.#isComp || (this.#isComp = !0, this.destroy()), St(this.parent) } getSwitchBox() { return this.#isComp || (this.#isComp = !0, this.destroy()), At(this.parent) } getPassWordBox() { return this.#isComp || (this.#isComp = !0, this.destroy()), Nt(this.parent) } getEmailBox() { return this.#isComp || (this.#isComp = !0, this.destroy()), kt(this.parent) } } class It { #props = { rowspan: 1, colspan: 1 }; constructor(t, e) { this.cell = t, this.column = e } add(t) { this.cell.add(t) } remove(t) { this.cell.remove(t) } removeAll() { this.cell.removeAll() } addAttr(t, e) { this.cell.addAttr(t, e) } addClass(t) { this.cell.addClass(t) } addEvent(t, e, s) { this.cell.addEvent(t, e, s) } removeClass(t) { this.cell.removeClass(t) } toggleClass(t) { this.cell.toggleClass(t) } getText() { return this.cell.getText() } setText(t) { this.cell.setText(t) } destroy() { this.cell.destroy() } spanCol(t) { return this.cell.spanCol(t), h.adaptTableCol(this.cell, this.cell.lsParent, this, t), this.#props.colspan = t, this } setStyle(t) { return this.cell.setStyle(t), this } spanRow(s) { const n = t => { t.destroy() }, i = C.getElementPosition(this.cell, this.column.column); let [a, o] = [[], 1]; this.column.column.forEach((t, e) => { e > i && (o++, v.arrAddWhen(a, t, o, s)) }), a.forEach(t => { let s = C.getElementPosition(t, t.lsParent.content); t.lsParent.content.forEach((t, e) => { e >= s && v.arrAddWhen(!1, t, e, this.#props.colspan, n) }) }), v.isEmpty(a) ? C.addPW(!0, this.cell, () => { v.after(200, () => { this.spanRow(s) }) }, this.cell.getPropWait()) : h.spanRow(this.cell, s) } span(t = 1, e = 1) { this.#props.colspan = t, this.#props.rowspan = e, this.spanCol(t), this.spanRow(e) } } class Ot { #heading; #table; constructor(t, e, s) { this.column = t, this.#heading = e, this.#table = s } setStyle(e) { h.forEachCol(this.column, t => { t.setStyle(e) }) } addClass(e) { h.forEachCol(this.column, t => { t.addClass(e) }) } removeClass(e) { h.forEachCol(this.column, t => { t.removeClass(e) }) } toggleClass(e) { h.forEachCol(this.column, t => { t.toggleClass(e) }) } getAttr(e) { h.forEachCol(this.column, t => { t.getAttr(e) }) } setText(e) { h.forEachCol(this.column, t => { t.setText(e) }) } drop() { h.dropColumn(this.column, this.#heading), --this.#table.columnCount, console.log(this.#table.columnCount) } } class Dt { #table; #Tcontent; #prop; #isInit; constructor(t, e) { this.parent = t, this.MainT = _.Card({ parent: t }), this.point = this.MainT, this.#table = e ? _.Div({ parent: this.MainT }) : _.Table({ parent: this.MainT }), this.#isInit = !1, C.addClassList(this.MainT, e ? e.cdCls : "leis-table-container"), C.addClassList(this.#table, e ? e.tablCls : "leis-table") } insertTable(n, t, i) { if (i = i || { cell: { elem: _.Td, cls: "leis-table-data" }, heading: { elem: _.Th, cls: "leis-table-heading" }, row: { elem: _.Tr, cls: "leis-table-row" }, header: { elem: _.THead, cls: "leis-table-head" }, body: { elem: _.Tbody, cls: "leis-table-body" } }, this.#isInit) throw new Error("tabel is already created"); if (!this.#isInit) { const a = [], o = (this.rowCount = t, this.columnCount = n, (t, s) => _.inRange(t, 0, t => { var t = _.P({ text: `data ${t + 1} x ` + (s + 1) }), e = (a.push(t), i.cell.elem({ content: [t] })); return C.addClassList(e, i.cell.cls), C.addClassList(t, "leis-table-defaultValue"), e })); var e = _.inRange(n, 0, t => { var t = _.P({ text: "heading " + (t + 1) }), e = (a.push(t), i.heading.elem({ content: [t] })); return C.addClassList(e, i.heading.cls), C.addClassList(t, "leis-table-defaultValue"), e }), t = _.inRange(t, 0, t => { t = i.row.elem({ content: o(n, t) }); return C.addClassList(t, i.row.cls), t }), e = i.header.elem({ parent: this.#table, content: e }), t = i.body.elem({ parent: this.#table, content: t }); this.#Tcontent = t, this.#prop = { header: e, bodyTable: t, count: 0 }, C.addClassList(e, i.header.cls), C.addClassList(t, i.body.cls), this.clear = function () { v.tryCode(() => { a.forEach(t => t.destroy()) }) }, this.addRow = function (t, e) { var s; C.hasConf(this.#table) ? (s = _.inRange(t, 0, t => { t = i.row.elem({ content: o(n, t + this.rowCount) }); return C.addClassList(t, i.row.cls), t }), this.#Tcontent.addElements(...s), e && (this.insertData(e, this.rowCount + 1), this.rowCount += t)) : C.addPW(!0, this.#table, () => { this.addRow(t, e) }, this.#table.getPropWait()) }, this.#isInit = !0 } } insertData(t, e) { h.insertData(t, this.#Tcontent, this.#prop, e) } getCell(t, e) { return new It(h.getCell(this.#Tcontent, t, e), this.getColumn(t)) } getRow(t) { return h.getRow(this.#Tcontent, t) } getColumn(t) { return new Ot(h.getColumn(this.#Tcontent, t, this.#prop.headingList), this.#prop.header.content[t - 1], this) } setHeading(t) { h.setHeading(this.#prop.header, t), this.#prop.headingList = t } update(s, t) { t && t.forEach((t, e) => { t.text && this.getCell(e + 1, s).setText(t.text), t.widget && ((e = this.getCell(e + 1, s)).removeAll(), e.add(t.widget)) }) } setSize(t, e) { t && this.MainT.setStyleProp("width", t), e && this.MainT.setStyleProp("height", e) } addRow(t, e) { throw new Error("table not created") } clear() { throw new Error("table not created") } addClass(t) { t && this.#table.addClass(t) } } class Lt extends A { getTable() { return Dt } } class _t extends A { } class jt extends A { } class Wt extends A { } class Mt extends A { } class Ht extends A { spanCol(t) { h.spanCol(this, t) } spanRow(t) { h.spanRow(this, t) } } class Rt extends A { } class T extends A { } class Ft extends A { } class $t { #prop = {}; constructor(t, e, s, n, i, a, o) { this.parent = s, this.link = t || [], this.content = e || [], this.attr = n, this.contentClass = i, this.useContentParent = a, this.concatLink = o, this.#setTab() } #setTab() { var [...t] = this.link; if ("object" != typeof this.content || "function" != typeof this.content.push) throw new Error("can only read a type of array"); { this.concatLink && (this.link = this.link.concat(this.concatLink)); const n = E(1, 4), i = E(1, 4), a = this.content, o = this.link; this.props = { _ei: n, __iConfig: i, widgtes: { __items: a, __links: o } }, this.content.forEach((t, e) => { var s = E(1, 5); if (void 0 === this.link[e]) throw new Error("miss a tabLink or tabContent, verify if you used array"); g(this.#prop, this.link[e]), t.attr && t.attr.className ? t.attr.className += String.fromCharCode(32) + "leis-tab-content" + String.fromCharCode(32) + i : t.attr.className = "leis-tab-content" + String.fromCharCode(32) + i, t.attr && t.attr.id, t.attr.id = s, this.link[e].attr && this.link[e].attr.className ? this.link[e].attr.className += `${String.fromCharCode(32)}leis-tabs-btn${String.fromCharCode(32)}${n}Btn ` : this.link[e].attr.className = `leis-tabs-btn${String.fromCharCode(32)}${n}Btn `, this.link[e].leisDataTab = { name: "data-leis-tab", value: `${s} ${i} ${n}Btn` }, this.link[e].linkName || (this.link[e].linkName = E(2, 10)), this.#prop[this.link[e].linkName] = { link: this.link[e], content: t }, (this.link[e].assContent = t).assLink = this.link[e], this.link[e].eventType = "click", this.link[e].eventOnce = function () { a.forEach(t => { P(t, t => { t.hide(), t.removeClass("active") }) }), o.forEach(t => t.removeClass("active")), P(t, t => { t.addClass("active"), t.show() }), o[e].addClass("active") } }) } var e = _.Card({ attr: { className: "leis-maintab" }, parent: this.parent }), t = _.Card({ attr: { className: "leis-tabs-card " + (this.attr && this.attr.className ? this.attr.className.join(" ") : "") }, parent: e, content: t }), s = _.Card({ attr: { className: "leis-mainContentTab " + (this.contentClass ? this.contentClass.join(" ") : "") }, parent: this.useContentParent || e, content: this.content }); return this.mainTab = e, this.point = e, this.__links__ = t, this.__contents__ = s, e } addTab(e, s, t = !1, n) { g(this.#prop, e), s.attr && s.attr.className ? s.attr.className += String.fromCharCode(r) + "leis-tab-content" + String.fromCharCode(r) + this.props.__iConfig : s.attr.className = "leis-tab-content" + String.fromCharCode(r) + this.props.__iConfig; var i = E(1, 5); s.attr && s.attr.id, s.attr.id = i, e.attr && e.attr.className ? e.attr.className += `${String.fromCharCode(r)}leis-tabs-btn${String.fromCharCode(r)}${this.props._ei}Btn ` : e.attr.className = `leis-tabs-btn${String.fromCharCode(r)}${this.props._ei}Btn `, e.leisDataTab = { name: "data-leis-tab", value: `${i} ${this.props.__iConfig} ${this.props._ei}Btn` }, e.linkName || (e.linkName = E(2, 4)), this.#prop[e.linkName] = { link: e, content: s }, (e.assContent = s).assLink = e; const a = this.props.widgtes; e.addEvent("click", function (t) { n && t.stopPropagation(), a.__items.forEach(t => { t.hide(), t.removeClass("active") }), a.__links.forEach(t => t.removeClass("active")), s.addClass("active"), s.show(), e.addClass("active") }), t || this.__links__.add(e), this.__contents__.add(s), this.content.push(s), this.link.push(e) } removeLink(t) { var e; C.hasConf(this.point) ? t && v.has(t, this.#prop) && ((e = this.#prop[t]).link.lsParent.remove(e.link), e.content.lsParent.remove(e.content), e = {}, v.copyObject(this.#prop, e, !1, t), this.#prop = e) : C.addPW(!0, this.point, () => { this.removeLink(t) }, this.point.getPropWait()) } moveLinkTo(t, e) { if (C.hasConf(this.point)) { if (!v.isTypeOf(e, A) || !v.has(t, this.#prop)) throw new Error("can only use the BaseElement or linkName not found"); var s = this.#prop[t]; s.link.lsParent.remove(s.link), e.add(s.link) } else C.addPW(!0, this.point, () => { this.moveLinkTo(t, e) }, this.point.getPropWait()) } addBtnClass(e) { C.hasConf(this.point) && e ? this.link.forEach(t => { "removed" !== t.state && t.addClass(e) }) : C.addPW(!0, this.point, () => { this.addBtnClass(e) }, this.point.getPropWait()) } destroy() { C.hasConf(this.point) ? (v.loopObj(this.#prop, (t, e) => { t.link.destroy(), t.content.destroy() }), this.point.destroy()) : C.addPW(!0, this.point, () => { this.destroy() }, this.point.getPropWait()) } invoke(t, e = !0) { C.hasConf(this.point) || !e ? t && v.has(t, this.#prop) && this.#prop[t].link.getAttr("click") : C.addPW(!0, this.point, () => { this.invoke(t) }, this.point.getPropWait()) } } class B { #button; #state = { active: !1, disable: !1 }; constructor(t) { this.#button = this.#setBtn(t), this.contentPage = t.contentPage, this.pageName = t.pageName || "Rand_" + E(2, 5), Object.defineProperty(this, "button", { value: this.#button }) } hasContent(t) { return !!t.content && (t.content ? !v.isEmpty(t.content) : !!t.content) } #setBtn(t) { var e = v.copyObject(t, !1, !1, "parent"), e = _.Div(e), e = _.Div({ content: [e], parent: t.parent }); return C.addClassList(e, "leis-page-legende"), e.btnPage = this, e } config(t) { return this.#setConfig(t), this.active(), this.#button } active() { this.#state.active || this.#setActive() } disable() { this.#state.active && this.#setDisable() } #setActive() { this.#button.addEvent("click", function (t) { this.pageConfig.parentPage || (this.pageConfig.parentPage = this.lsParent.accessPage.p), this.pageConfig.parentPage.history && (this.pageConfig.parentPage.history.push(this.pageConfig.contentPage), this.pageConfig.parentPage.content.forEach(t => { t.hide() }), this.pageConfig.contentPage.show(), this.pageConfig.parentPage.page.currentPage = this.pageConfig.contentPage, this.lsParent.accessPage || (this.lsParent.accessPage = this.pageConfig.contentPage.accessPage), this.lsParent.accessPage._controler.show()) }, "pageButtonActive"), this.#state.active = !0 } #setDisable() { this.#button.removeEvent("click", "pageButtonActive"), this.#state.active = !1 } #setConfig(t) { (this.#button.pageConfig = t).parentPage.add(t.contentPage), t.contentPage.accessPage = t.parentPage.accessPage, v.isArray(t.contentPage.attr.className) ? t.contentPage.attr.className.push("leis-page-content") : t.contentPage.attr.className += " leis-page-content ", C.hasConf(t.contentPage) && t.contentPage.addClass("leis-page-content") } } class Ut { #prop = { start: !1 }; constructor(t, e, s) { this.parent = t, this.legend = e || [], this.content = s || [], this.point = this.#setPage(), this.currentPage = "main" } removePage(t) { var e, s; C.hasConf(this.point) && t ? (w(this.#prop, t, !0), e = this.#prop[t].button, s = this.#prop[t].content, e.lsParent.remove(e), s.lsParent.remove(s), this.#prop = v.copyObject(this.#prop, !1, !1, t)) : C.addPW(!0, this.point, () => { this.removePage(t) }, this.point.getPropWait()) } invoke(t) { C.hasConf(this.point) && t ? (w(this.#prop, t, !0), this.#prop[t].button.getAttr("click")) : C.addPW(!0, this.point, () => { this.removePage(t) }, this.point.getPropWait()) } #setPage() { const i = this.#prop, n = this, a = _.Card({ attr: { className: "leis-mainPage" }, parent: this.parent }), o = _.Button({ attr: { className: "leis-btn-controler hide " }, eventType: "click", parent: a, eventOnce: function () { this.lsParent.content.forEach(t => t.hide()); let e = {}, s = []; this.lsParent.history.forEach(t => { t.leisBtnConfId in e == !1 && (s.push(t), e[t.leisBtnConfId] = t) }), s.length <= 1 ? (this.hide(), this.lsParent.history = [this.lsParent.history[0]], e = {}, n.currentPage = "main") : (this.show(), s.pop()); var t = (this.lsParent.history = s)[s.length - 1]; t.show(), n.currentPage = t, 1 == s.length && (this.hide(), n.currentPage = "main") } }); d.PageControler = o; var t = _.Card({ content: this.content }), e = _.Card({ attr: { className: ["contentP-Default", "noBP"] }, content: [t].concat(this.legend), parent: a }); if (e.accessPage = { p: a, _controler: o }, this.mainPage = a, this.home = t, a.accessPage = { p: a, _controler: o }, a.history = [e], "object" != typeof (a.page = this).legend || "function" != typeof this.legend.push) throw new Error("the ledende property needs only the array, verify if you used an array object"); function s(t, e, s) { var n; v.isTypeOf(t, B) ? (w(i, t), n = t.config({ access: "true", parentPage: a, contentPage: t.contentPage }), i[t.pageName] = { button: n, content: t.contentPage }, n.parent !== A || s || t.noP || e.home.add(n), v.isTypeOf(s, A) && s.add(n)) : (t.pageConfig.contentPage.accessPage = { p: a, _controler: o }, a.add(t.pageConfig.contentPage), t.pageConfig.contentPage.attr.className += String.fromCharCode(r) + "leis-page-content" + String.fromCharCode(r)) } return this.legend.forEach(t => { s(t, this) }), this.addButton = (t, e) => { s(t, this, e) }, this.define = function (t, e) { var s; t && e && (w(this.#prop, t, !1), s = new B({ otherAttr: { type: "hidden" } }).config({ access: "true", parentPage: a, contentPage: e }), this.home.add(s), i[t] = { button: s, content: _.Div({ content: [e] }), hidden: !0 }) }, a } } class Vt { constructor(t, e, s, n = void 0, i = void 0, a = void 0) { this.AccBtn = t, this.AccPanel = e, this.parent = s, this.accHeader = n, this.accFooter = i, this.props = a, this.point = this.#setAcc() } #setAcc() { const n = _.Card({ attr: { className: ["leis-accordion-card"].concat(this.props && this.props.className || []) }, parent: this.parent, otherAttr: this.props && this.props.otherAttr || void 0 }); if (void 0 !== this.accHeader && (this.accHeader.attr ? this.accHeader.attr.className ? this.accHeader.attr.className += " leis-accordion-head " : this.accHeader.attr.className = ["leis-accordion-head"] : this.accHeader.attr = { className: ["leis-accordion-head"] }, n.content.push(this.accHeader)), "object" != typeof this.AccBtn || "function" != typeof this.AccBtn.push) throw new Error("the Accordion widget needs only the array, verify if you used an array object"); return this.AccBtn.forEach((t, e) => { if (t.attr && t.attr.className ? t.attr.className += " leis-accordion-btn " : t.attr.className = " leis-accordion-btn ", void 0 === this.AccPanel[e]) throw new Error("missing a pannel widget"); { this.AccPanel[e].attr ? this.AccPanel[e].attr.className ? this.AccPanel[e].attr.className += " leis-accordion-panel " : this.AccPanel[e].attr.className = " leis-accordion-panel " : this.AccPanel[e].attr.className = "leis-accordion-panel", t.eventType = "click"; const s = this.AccPanel[e]; t.eventOnce = function () { s.toggleClass("active"), t.toggleClass("active") }, n.content.push(t), n.content.push(this.AccPanel[e]) } }), void 0 !== this.accFooter && (this.accFooter.attr ? this.accFooter.attr.className ? this.accFooter.attr.className += " leis-accordion-footer " : this.accFooter.attr.className = ["leis-accordion-footer"] : this.accFooter.attr = { className: ["leis-accordion-footer"] }, n.content.push(this.accFooter)), this.MainAcc = n } addItem(t, e) { this.MainAcc.content.push(t), t.attr && t.attr.className ? t.attr.className += " leis-accordion-btn " : t.attr.className = " leis-accordion-btn ", this.MainAcc.content.push(e), e.attr ? e.attr.className ? e.attr.className += " leis-accordion-panel " : e.attr.className = " leis-accordion-panel " : e.attr.className = "leis-accordion-panel", t.eventType = "click", t.eventOnce = function () { e.toggleClass("active"), t.toggleClass("active") }, this.MainAcc.CASCADE() } destroy() { this.point.destroy() } addClass(t) { this.MainAcc.addClass(t) } remove(t) { this.MainAcc.remove(t) } removeAll() { this.MainAcc.removeAll() } setStyle(t) { this.MainAcc.setStyle(t) } } class Gt { constructor(t, e, s, n) { this.items = e, this.parent = t, this.attr = s, this.header = n, this.checked = null, this.#setG() } addItem(t) { C.addClassList(t, "leis-child-group"), this.MainG.addItem(t) } removeAll() { this.MainG.removeAll() } #setG() { var t = _.Card({ parent: this.parent, attr: { className: ["leis-group"] } }); const e = _.List({ attr: { className: ["leis-list-group"].concat(this.attr && this.attr.className || []) }, parent: t }); void 0 !== this.header && (this.header.attr ? this.header.attr.className ? this.header.attr.className += " leis-child-group leis-group-head " : this.header.attr.className = " leis-child-group leis-group-head " : this.header.attr.className = "leis-child-group leis-group-head", e.content.push(this.header)), void 0 !== this.items && "function" == typeof this.items.push && this.items.forEach(t => { "li" === t.ElementType.toLowerCase() && (t.attr ? t.attr.className ? t.attr.className += " leis-child-group " : t.attr.className = " leis-child-group " : t.attr.className = "leis-child-group", e.content.push(t)) }), this.point = t, this.MainG = e } } function I(a, o = A, r) { return function (e) { if (null != (e = e || {}).eventOnce) { const i = e.eventOnce; function t(t) { i.call(this.currentElement, t) } e.eventOnce = t, e.listener && (t.prototype.name = e.listener) } const s = new o(e); s.ElementType = a; var n = { label: () => s.lblFor = e.lblFor || "", button: () => { s.className += String.fromCharCode(32) + "btn" + String.fromCharCode(32), s.otherAttr.type = "button" }, img: () => { s.src = e.src || "", s.alt = e.alt || "" } }[r.toLowerCase()]; return p.forEach(t => { s[t] = e[t] || "" }), n && n(), m.forEach(t => t(e, s)), s } } class zt {
        #privPro = {}; constructor(t, e, s, n, i, a) { this.parent = t, this.listImg = e, this.width = s, this.height = n, this.maxHeight = i, this.minHeight = a, this.point = this.#setS() } #setImg(t, n, i, a, e, o = 0) { const r = this; t.forEach((t, e) => { e += o; var s = _.Card({ parent: n }), s = _.Card({ content: [_.Img({ otherAttr: { src: t.src || "", style: this.minHeight ? `min-height:${this.minHeight}px` : "auto" } }), _.Card({ attr: { className: ["leis-slideshowNumTxt"] } })], attr: { className: ["leis-img-card", a, "fade"] }, parent: s }); n.addData.push(_.Card({ text: t.caption || "", attr: { className: ["leis-slideshow-txt"] }, parent: n, otherAttr: { style: "display:none" } })), _.Span({ attr: { className: ["leis-slideshow-dot"] }, addData: { img: s }, parent: i, eventType: "click", eventOnce: function () { i.content.forEach((t, e) => { t.addData.img.hide(), t.removeClass("active") }), this.addData.img.show(), this.addClass("active"), n.addData.forEach(t => t.hide()), n.addData[e].show(), this.addData.img.content[1].setText(e + 1 + "/" + r.listImg.length) } }) }) } addImg(t) { var e = this.listImg.length; this.listImg = this.listImg.concat(t), this.#setImg(t, this.#privPro.MainS, this.#privPro.dotCard, this.#privPro.imgId, this.#privPro.counter, e), this.#privPro.MainS.CASCADE(), this.#privPro.dotCard.CASCADE() } #setS() {
            var t = E(3, 8), e = _.Card({ parent: this.parent }), s = _.Card({
                attr: { className: ["leis-slideshow-container"] }, parent: e, otherAttr: {
                    style: (`width:${this.width ? this.width + "px" : "auto"};
                 height:${this.height ? this.height + "px" : "auto"};
                 max-height:`+ (this.maxHeight ? this.maxHeight + "px" : "auto")).replace(/\n/g, "")
                }, addData: []
            }); let n = 0; _.Span({ autoClick: !0, innerHtml: "&#10094", attr: { className: ["leis-slideshow-prev-btn"] }, parent: s, eventType: "click", eventOnce: function () { n = 0 == n ? i.content.length - 1 : n - 1, i.content[n].getAttr("click") } }), _.Span({ innerHtml: "&#10095", attr: { className: ["leis-slideshow-next-btn"] }, parent: s, eventType: "click", eventOnce: function () { n = n == i.content.length - 1 ? 0 : n + 1, i.content[n].getAttr("click") } }); const i = _.Card({ otherAttr: { style: "text-align:center" }, parent: e }); return this.listImg && this.#setImg(this.listImg, s, i, t, n), this.MainS = e, this.#privPro.MainS = s, this.#privPro.imgId = t, this.#privPro.dotCard = i, this.#privPro.imgId = t, this.#privPro.counter = n, e
        }
    } class qt { #CaptionDisplay; #contentDC; constructor(t, e, s, n, i, a, o = !1, r) { this.parent = t, this.caption = e, this.items = s, this.btnType = n, this.attr = i, this.useBtn = a, this.contentStopPropagation = o, this.btnClass = r, this.point = this.#setD() } setCaption(t) { this.#CaptionDisplay.setText(t) } addItem(t) { _.Span({ content: [t], parent: this.#contentDC }), this.#contentDC.CASCADE() } #setD() { this.#CaptionDisplay = _.Span({ text: this.caption }); var t = _.Card({ attr: { className: ["leis-dropdown"].concat(this.attr && this.attr.className || []) }, parent: this.parent }); let e; void 0 !== this.useBtn && (e = _.Card({ attr: { className: ["leis-dropBtn"].concat(this.btnClass || []) }, content: [this.useBtn], eventType: "click", eventOnce: function (t) { t.stopPropagation(), d.lDropDown.forEach(t => { t.Dcontent.removeClass("show"), t.Btn.removeClass("activeD") }), this.addClass("activeD"), i.addClass("show") } })); var s = _.Button({ attr: { className: ["leis-dropBtn leis-flex leis-row", "leis-dropBtn-" + String(this.btnType || "primary")].concat(this.btnClass || []) }, eventType: "click", content: [this.#CaptionDisplay, _.Span({ otherAttr: { class: "leis-arrow-down as" } })], eventOnce: function (t) { t.stopPropagation(), d.lDropDown.forEach(t => { t.Dcontent.removeClass("show"), t.Btn.removeClass("activeD") }), this.addClass("activeD"), i.addClass("show") } }), n = (t.content.push(e || s), _.Card({ attr: { className: ["leis-content"] }, parent: t })); const i = _.Card({ attr: { className: ["leis-dropdown-content", "leis-padding-6", "leis-border-" + String(this.btnType || "primary")] }, parent: n }), a = _.Card({ attr: { className: ["leis-dropdwn-content-card"] }, parent: i }); return this.#contentDC = a, !0 === this.contentStopPropagation && a.addEvent("click", function (t) { t.stopPropagation() }), void 0 !== this.items && "function" == typeof this.items.push && this.items.forEach(t => { a.content.push(t) }), this.MainD = t, this.Dcontent = i, this.Btn = e || s, this.setSize = function (t, e) { t && i.setStyleProp("width", t), e && i.setStyleProp("height", e) }, this.addClass = function (t) { i.addClass(t) }, this.setStyle = function (t) { i.setStyle(t) }, t } hideContent() { window.document.body.click() } destroy() { this.point.destroy() } } class Kt { #position; #type; #dropDowns; constructor(t, e, s, n, i) { this.parent = t, this.links = e, this.type = n, this.#position = s, this.#dropDowns = i, this.point = this.#setTop() } #setTop() { var t, e = _.Card({ parent: this.parent, attr: { className: ["leis-topnav", "" + (this.type || "")] } }); return v.isUndifend(this.links) || v.isArray(this.links) && (t = this.links.map(t => _.Li({ content: [_.A({ otherAttr: { href: t.href }, text: t.name })] })), this.#dropDowns && C.topNaveDropDowns(_, t, this.#dropDowns), e.add(_.GroupItem({ items: t }).MainG)), e } } class Jt { #footer; #header; #items; constructor(t, e, s, n, i) { this.parent = t, this.#header = e, this.#footer = s, this.#items = n, this.collapsibles = i, this.point = this.#setSB() } #setSB() { var t = _.Card({ attr: { className: ["sideNavHeader"] } }), e = _.Card({ attr: { className: ["sideNavFooter"] } }); const n = []; if (!v.isUndifend(this.#items)) { let e = t => { var s = []; return t.forEach(e => { var t = _.Li(); t.addEvent("click", function () { n.forEach(t => t.removeClass("sideItemActive")), this.addClass("sideItemActive"), v.isUndifend(e.action) || e.action.call(this, this) }), e.icon && t.content.push(_.I({ otherAttr: { class: e.icon }, events: { click: function (t) { e.onIcon && e.onIcon(t) } } })), e.caption && t.content.push(_.Span({ text: e.caption })), e.widget && t.content.push(e.widget), n.push(t), s.push(t) }), s }; v.tryCode(() => { e(this.#items) }), this.addItems = function (t) { v.tryCode(() => { e(t).forEach(t => s.addItem(t)) }) } } this.collapsibles && C.insertItemFlat(_, n, this.collapsibles, "MainC", "colla-item"); const s = _.GroupItem({ items: v.isEmpty(n) ? void 0 : n, attr: { className: ["links"] } }); var i = [s.MainG]; v.isUndifend(this.#header) || (t.add(this.#header), v.arrayInsert(0, i, t)), v.isUndifend(this.#footer) || (e.add(this.#footer), i.push(e)); const a = _.Card({ attr: { className: ["leis-sideNav"] }, content: i }); return this.setWidth = function (t) { t && a.setStyleProp("width", t) }, this.addClass = function (t) { t && a.addClass(t) }, this.MainS = a, Object.defineProperty(this, "allItems", { value: n }), a } } class Qt { constructor(t, e, s) { this.parent = t, this.content = e, this.caption = s, this.point = this.#setC() } #setC() { var t = _.Card({ attr: { className: ["leis-collapsing-container"] }, parent: this.parent }); _.Button({ text: this.caption, attr: { className: ["leis-collapse-btn"] }, parent: t }).addEvent("click", function () { e.toggleClass("callo-show"), this.toggleClass("colla-btn-show") }); const e = _.Card({ attr: { className: ["leis-collapsing"] }, parent: t, content: this.content }); return this.MainC = t } } function Xt(t) { t = t || {}, v.isUndifend(t.option) && (t.option = {}); var e, s = C.setSearchBar(_, t); return t.option.autoComplate ? (t = t, e = { point: _.Card({ attr: { className: ["leis-autoComplate"] }, content: [e = s, C.setAutoComplation(_, t.option.autoComplate, e, t.option.defaultValue, t.option)] }) }) : s } class Yt { #prop = t(); constructor(t) { this.parent = t, this.point = this.#setModal(), Object.defineProperty(this, "events", { writable: !1, value: { close: [], active: [] } }) } #setModal() { const n = _.Div({ parent: this.parent }), s = _.Div({ parent: n }); var t = _.CloseBtn({}), e = (t.addEvent("click", function () { l() }), _.Div()), i = _.H3({ text: "modal title" }), a = _.Button({ text: "Close" }).getButton(), o = (a.setType("secondary"), this.closeBtn = a, _.Button({ text: "Save data" }).getButton()), a = (o.setType("primary"), this.saveBtn = o, _.Div({ content: [a, o] })), o = _.P({ text: "Modal content goes here... add new content", tooltip: { postion: "bottom", text: "text modal example" } }), r = (this.#prop.body.add(o), this.#prop.footer.add(a), this.#prop.header.add(i), this.#prop.header.add(t), e.add(this.#prop.header), e.add(this.#prop.body), e.add(this.#prop.footer), s.add(e), n.addEvent("click", function (t) { t.target === this._conf && l() }), C.addClassList(n, "leis-modal-container"), C.addClassList(s, "leis-modal-dialog modal-transform"), C.addClassList(e, "leis-modal-content"), C.addClassList(this.#prop.header, "leis-modal-header"), C.addClassList(this.#prop.body, "leis-modal-body"), C.addClassList(this.#prop.footer, "leis-modal-footer"), C.addClassList(i, "leis-modal-title"), C.addClassList(a, "leis-modal-footer-card"), C.addClassList(o, "leis-modal-dafault"), this.#prop.content = e, this.#prop.title = i, this.#prop.container = n, this.#prop.p = o, this._modal_ = n, this.#prop.dialog = s, Object.defineProperty(this, "props", { value: this.#prop }), this); function l() { var s = { closable: !0 }; r.events.close.forEach((t, e) => { t(s) }), s.closable && n.removeClass("show") } return this.hide = l, Object.defineProperty(this, "body", { writable: !1, value: this.#prop.body }), this.setEffect = function (t) { s.setStyleProp("animationName", "" + t) }, this.moveTo = function (t, e) { s.setStyleProp("top", 100 * e / window.screen.availHeight + "%"), s.setStyleProp("left", 100 * t / window.screen.availWidth + "%"), s.removeClass("modal-transform"), n.setStyleProp("background", "inherit"), this.show() }, n } setTitle(t) { this.#prop.title.setText(t) } show() { var s = { active: !0 }; this.events.active.forEach((t, e) => { t(s) }), s.active && this.#prop.container.addClass("show") } add(t) { this.#prop.body.add(t) } addElements(...t) { this.#prop.body.addElements(...t) } setSize(t, e) { t && this.#prop.dialog.setStyleProp("width", t), e && this.#prop.dialog.setStyleProp("height", e) } addClass(t) { t && this.#prop.dialog.addClass(t) } clearDefault() { this.#prop.p.destroy() } clear() { this.#prop.p.destroy() } destroy() { this.#prop.container.destroy() } once(t, e) { v.has(t, this.events) && this.events[t].push(e) } removeFooter() { this.#prop.footer.destroy() } removeHeader() { this.#prop.header.destroy() } } function Zt(e, s) { (s = s || {}).target || (s.target = e); var n, i = { start: "mousemove", end: "mouseup", init: "mousedown" }; function a(t) { s.end && s.end(t), e.removeEvent(i.start, "start"), e.removeEvent(i.end, "end") } (n = s).target.addEvent(i.init, function (t) { var s; n.start && n.start(t), s = n, e.addEvent(i.start, t => { var e; t = t, (e = s).listener && e.listener(t) }, "start"), e.addEvent(i.end, a, "end") }, "init") } class te { constructor(t) { this.text = t } get(t = {}) { var e = this.text.split(" "); let s = ""; for (var n = 0; n < e.length; n++)2 <= e[n].length && "%" == e[n][0] && null != t[e[n].slice(1, e[n].length)] && (e[n] = t[e[n].slice(1, e[n].length)]); for (var i = 0; i < e.length; i++)0 <= e[i].length && "%" != e[i][0] && (s += " " + e[i]); return s } } class ee { #type; #links; constructor(t, e, s, n) { this.parent = t, this.text = e, this.#type = s, this.#links = n, this.point = this.#setA() } #setA() { var t = new te(this.text); let e; if (this.#links) { const { ...n } = this.#links; Object.keys(n).forEach(t => { n[t] = `<a href="${n[t]}">${t.replace(/_/g, " ")}</a>` }), e = t.get(n) } t = _.CloseBtn("click", function () { s.destroy() }); const s = _.Card({ parent: this.parent }); return _.Card({ parent: s, content: [t, _.P({ innerHtml: e || this.text, attr: { className: ["leis-alert-text"] } })], attr: { className: ["leis-alert-card", this.#type ? "leis-alert-" + this.#type : "leis-alert-primary"] } }), this.MainA = s } } class se { constructor(t) { this.items = (t = t || {}).items, this.point = _.Input().getTextBox(), this.point.autoComplete = { autoComplete: this.items }, Object.defineProperty(this, "combo", { writable: !1, value: this.point.add() }); let e = v.countArray(this.items, 0); this.combo.leisBtnConfId.input.bind("<arrow>", function (t) { t.up = () => { this.setValue(e()) } }, "choice"), this.combo.leisBtnConfId.input.bind("<return>", function () { console.log(this) }) } } function ne({ byId: t = !1, id: e = new String, byClassName: s = !1, className: n = new String, byElement: i = !1, htmlElement: a = new Document, event: o = function (t = 0, e = document.getElementById("gggfgfgkhfk@!jdhhks22222252674dkfhjhggffsdlohvgfdk=hggd")) { }, evt: r = new String, getElm: l = { byId: !1, IdValue: new String, byClassName: !1, classValue: new String }, pre: h = function ({ currentElement: t = new Document, elemAss: e = new Document }) { }, content: c = new Array }) { let d; try { d = l.byId ? document.querySelector("#" + (l.IdValue || "ffff5256gshs")) : l.byClassName ? document.querySelector("." + (l.classValue || "")) : void 0 } catch (t) { } t ? document.querySelector("#" + (e || null)).addEventListener("" + (r || ""), function (t) { o(t, d) }) : i ? a.addEventListener("" + (r || ""), function (t) { o(t, d) }) : s && document.querySelector("." + (n || null)).addEventListener("" + (r || ""), function (t) { o(t, d) }); const p = t ? document.querySelector("#" + (e || null)) : i ? a : s ? document.querySelector("." + (n || null)) : void 0; return h({ currentElement: p, elemAss: d }), c && c.forEach(t => { p && (t.parent = p, t.point ? (t.point.parent = p).append(t.point.render()) : (p.append(t.render()), t.parent = p)) }), p } class O { constructor(t, e, s) { this.point = _.Div({ parent: t, content: e }), C.addClassList(this.point, s[0]), this.#setHB(e, s[1]) } #setHB(e, s) { e.forEach(t => { t.addClass(s), t.setStyleProp("flex", "" + e.length) }) } #setItemFlex(t, e, s) { this.point.content[t] && this.point.content[t].setStyleProp(e, s) } setItemGrow(t, e) { this.#setItemFlex(t, "flexGrow", e) } setItemShrink(t, e) { this.#setItemFlex(t, "flexShrink", e) } setItemBasis(t, e) { this.#setItemFlex(t, "flexBasis", e) } setItemOrder(t, e) { this.#setItemFlex(t, "flexOrder", e) } } O.HBoxLayout = function (t, e) { return new this(t, e, ["leis-flex leis-row leis-layout", "leis-hbox-item"]) }, O.VBoxLayout = function (t, e) { return new this(t, e, ["leis-flex leis-colun leis-layout", "leis-vbox-item"]) }; var D, L = { theme: "light", Core: _ }; const ie = {}, ae = { BaseElement: A, leis: C, obj: v, leisDOM: l, generateId: E, selectElement: ne, groupController: function ({ byClassName: t = !1, classValue: e = new String, byChildren: s = !1, parent: n = new Document }) { var i = t ? document.querySelectorAll("." + (e || "")) : s ? n.children : void 0, a = []; if (void 0 !== i) for (let t = 0; t < i.length; t++)a.push(i[t]); return a }, ExtensionInit: y, ExtensionRender: s, OptionsInit: m, useState: b }; function _(t) { t = t || {}, v.copyObject(t, L, !0), t.plugin && t.plugin.forEach(t => { v.tryCode(() => t(L)) }) } _.prototype.setting = L, Object.defineProperty(_, "extension", { writable: !1, value: {} }), Object.defineProperty(_, "event", { writable: !1, value: o() }), _.Button = t => { return I("button", tt, "Button")(t) }, _.Card = t => { return I("div", et, "div")(t) }, _.Label = t => { return I("label", nt, "label")(t) }, _.Paragraph = t => { return I("p", i, "paragraph")(t) }, _.P = t => { return I("p", i, "paragraph")(t) }, _.Img = t => { return I("img", it, "img")(t) }, _.Div = t => { return I("div", st, "div")(t) }, _.List = t => { return I("ul", a, "ul")(t) }, _.Ol = t => { return I("ol", a, "ol")(t) }, _.Ul = t => { return I("ul", a)(t) }, _.Li = t => { return I("li", at, "li")(t) }, _.Span = t => { return I("span", ot, "span")(t) }, _.I = t => { return I("i", rt, "i")(t) }, _.Link = t => { return I("link", lt, "link")(t) }, _.A = t => { return I("a", ht, "a")(t) }, _.Textarea = t => { return I("textarea", Tt, "textarea")(t) }, _.Table = t => { return I("table", Lt, "table")(t) }, _.THead = t => { return I("thead", _t, "thead")(t) }, _.Th = t => { return I("th", jt, "th")(t) }, _.Tbody = t => { return I("tbody", Mt, "tbody")(t) }, _.Tr = t => { return I("tr", Wt, "tr")(t) }, _.Td = t => { return I("td", Ht, "td")(t) }, _.Tfoot = t => { return I("tfoot", Rt, "tfoot")(t) }, _.Script = I("script", ct, "script"), _.Input = t => { return I("input", Bt, "input")(t) }, _.H1 = I("h1", T, "h1"), _.H2 = I("h2", T, "h2"), _.H3 = I("h3", T, "h3"), _.H4 = I("h4", T, "h4"), _.H5 = I("h5", T, "h5"), _.H6 = I("h6", T, "h6"), _.Style = I("style", Ft, "style"), _.Head = ((D = (D = _.Div)())._config = window.document.head, D), _.addStyle = function (t) { C.addCssFile(document, this.Style({ text: t })) }, _.inRange = function (e, s = 0, t) { let n = []; for (let t = s; t < e; t++)n.push(t); return n = n.map(t) }, _.TabPage = t => (t = t || {}, new $t(t.tabLink, t.tabContent, t.parent, t.attr, t.contentClass, t.useContentParent, t.concatLink)), _.pageButton = (t = {}) => new B(t), _.Page = t => new Ut(t.parent, t.legend, t.content), _.Accordion = t => new Vt(t.accBtn, t.accPanel, t.parent, t.accHeader, t.accFooter, t.props), _.GroupItem = t => new Gt(t.parent, t.items, t.attr, t.header), _.GILeftImg = t => _.Card({ attr: { className: ["leis-img-group-left"] }, content: [_.Img({ otherAttr: { src: t } })] }), _.GIText = t => _.Paragraph({ attr: { className: ["leis-group-txt"] }, text: t }), _.setPage = function (t, e) { ie[t] = e }, _.getPage = t => ie[t], _.lorem = "Lorem ipsum dolor sit amet consectetur adipisicing elit. Earum distinctio molestias culpa dolores quibusdam doloribus iure quis. Facere consequatur rerum quidem totam optio est animi. Voluptatem temporibus blanditiis officia enim!", _.MLorem = function (e = 1) { let s = ""; for (let t = 0; t < e; t++)s += ` ${this.lorem} `; return s }, _.DropDown = (t = {}) => { t = new qt(t.parent, t.caption, t.items, t.btnType, t.attr, t.useBtn, t.stopPropagation, t.btnClass); return d.lDropDown.push(t), t }, _.SlideDown = t => new zt(t.parent, t.imgList, t.width, t.height, t.maxHeight, t.minHeight), _.Alert = t => new ee(t.parent, t.text, t.type, t.links), _.SideBar = (t = {}) => new Jt(t.parent, t.header, t.footer, t.items, t.collapsible), _.TopNav = (t = {}) => new Kt(t.parent, t.links, t.position, t.type, t.dropDowns), _.Collapsible = t => new Qt(t.parent, t.content, t.caption), _.SearchBar = t => Xt(t), _.CloseBtn = function (t, e) { return this.Button({ content: [this.Span({ innerHtml: "&times" })], otherAttr: { class: "leis-btn-close" }, eventOnce: e, eventType: t }) }, _.Modal = t => (t = t || {}, new Yt(t.parent)), _.ComboBox = t => new se(t), _.HBoxLayout = t => (t = t || {}, O.HBoxLayout(t.parent, t.content)), _.VBoxLayout = t => (t = t || {}, O.VBoxLayout(t.parent, t.content)), _.winClicked = t => d.Callbacks.push(t), _.getPageControler = () => d.PageControler, window.addEventListener("click", function (t) { d.lDropDown.forEach(t => { t.Dcontent.removeClass("show"), t.Btn.removeClass("activeD") }), d.Callbacks.forEach(t => t()) }), _.insertCss = function (t) { t = this.Link({ otherAttr: { type: "text/css", rel: "stylesheet", href: t } }); return C.addCssFile(document, t), t }, _.main = function (e, s) { const i = e.Div(); return i.otherAttr = { class: "leis-main" }, i._conf = s, new class { constructor() { const t = e.Div(); v.after(200, () => { t._conf = s.document.body, this.allScripts = s.document.scripts }), t._conf = s.document.body, this.body = t } onPressMove(t, e, s, n) { Zt(i, { listener: e, target: t, start: s, end: n }) } addEvent(...t) { i.addEvent(...t) } getScreen() { return s.screen } } }(_, window), Object.defineProperty(_, "MPC", { writable: !1, value: _.Div() }), _.defineExtension = function (t, e, s) { this[t] = v.after(200, () => { e(L, _, ae) }), this.extension[t] = e }, _.whenReady = function (t, ...e) { C.hasConf(this.MPC) ? v.after(200, t, ...e) : this.MPC.getPropWait().push(() => { v.after(200, () => { v.tryCode(() => { t.call(this.MPC) }, t => { console.error(t); var e = this.Modal(); e.setTitle("Error occured"), e.show(), e.add(this.P({ text: t.message })), e.setSize("50%", "50vh"), e.clear(), window.document.body.append(e.point.render()) }) }) }) }, _.createContent = function (s, t, n) { return v.isFunction(n) ? this.inRange(t, 0, (t, e) => n(this[s](), e, this[s])) : this.inRange(t, 0, (t, e) => this[s]()) }; const oe = function (t, n) { const i = [], a = (t && (t.imports = t => e(t, n), t.exports = (t, e) => s(t, e)), o()); function s(e, t) { a.handle(t, function (t) { t.send(e) }) } function e(e, s) { return v.after(300, function () { for (var t = 0; t < n.main.allScripts.length; t++)i.push(n.main.allScripts.item(t).src); !function (t) { for (var e = !1, s = 0; s < i.length; s++)if (i[s].endsWith(t.replace(/\.\//g, ""))) { e = !0; break } return e }(e) && s.main.body.add(s.Script({ otherAttr: { src: e } })) }), { on: a.invoke } } return { exportsLeisObject: s, importsObject: e } }(globalThis, _); return _.exports = (t, e) => oe.exportsLeisObject(t, e), _.imports = t => oe.importsObject(t, _), _.dep = ae, Object.defineProperty(_, "selectElement", { writable: !1, value: ne }), Object.defineProperty(_, "render", { writable: !1, value: function (t) { this.selectElement({ byId: !0, id: t, content: [this.MPC] }) } }), _
});